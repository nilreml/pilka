#version 450

layout(std430, push_constant) uniform PushConstant {
	vec3 pos;
	float time;
	vec2 resolution;
	vec2 mouse;
	float spectrum;
} pc;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (binding = 0, rgba8) uniform image2D previous_frame;
layout (binding = 1, rgba8) uniform image2D generic_texture;
layout (binding = 2, rgba8) uniform image2D dummy_texture;
layout (binding = 3, r32f) uniform image2D float_texture1;
layout (binding = 4, r32f) uniform image2D float_texture2;

float conv(in float[9] kernel,
           in float[9] data,
           in float denom,
           in float offset) {
    float res = 0.0;
    for (int i = 0; i < 9; ++i) {
        res += kernel[i] * data[i];
    }
    return clamp(res / denom + offset, 0.0, 1.0);
}

struct ImageData {
    float avg[9];
} imageData;

void main() {
    if (gl_GlobalInvocationID.x >= pc.resolution.x ||
        gl_GlobalInvocationID.y >= pc.resolution.y) {
        return;
    }

    // Fetch neighbouring texels
    int n = -1;
    for (int i = -1; i < 2; ++i) {
        for (int j = -1; j < 2; ++j) {
            n += 1;
            vec3 rgb =
                imageLoad(previous_frame, ivec2(gl_GlobalInvocationID.x + i,
                                                gl_GlobalInvocationID.y + j))
                    .rgb;
            imageData.avg[n] = (rgb.r + rgb.g + rgb.b) / 3.0;
        }
    }

        float[9] kernel;
	kernel[0] = -1.0/8.0; kernel[1] = -1.0/8.0; kernel[2] = -1.0/8.0;
	kernel[3] = -1.0/8.0; kernel[4] =  1.0;     kernel[5] = -1.0/8.0;
	kernel[6] = -1.0/8.0; kernel[7] = -1.0/8.0; kernel[8] = -1.0/8.0;

	vec4 res = vec4(vec3(conv(kernel, imageData.avg, 0.1, 0.0)), 1.0);

	imageStore(float_texture1, ivec2(gl_GlobalInvocationID.xy), vec4(pc.mouse, 0.2, 1.0));
}
